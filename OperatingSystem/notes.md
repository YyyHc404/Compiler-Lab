## 外存:
#### 扇区:
扇区是磁盘存储设备（如硬盘、软盘和光盘）上的最小物理存储单位。每个扇区通常为512字节或4096字节（4KB）
- CSM (Compatibility Support Module) 是 UEFI 的一个组件，旨在提供对传统 BIOS 启动模式的兼容性。通过启用 CSM，计算机可以在 UEFI 固件中以传统 BIOS 模式启动，从而支持旧的操作系统和设备。

**PXE (Preboot Execution Environment)** 是一种用于在没有本地存储设备（如硬盘）的计算机上，通过网络启动操作系统的技术。PXE 常用于大型企业环境中的无盘工作站或远程安装操作系统。
- **PXE 的工作原理**
- PXE 是一种客户端-服务器架构，它允许计算机在启动时通过网络从远程服务器加载操作系统映像。PXE 的基本工作流程如下：

- DHCP 发现：
  - 计算机启动并进行 PXE 引导时，会发送一个 DHCP（Dynamic Host Configuration Protocol）请求，以获取网络配置信息，包括 IP 地址和引导服务器的地址。
- DHCP 响应：
  - DHCP 服务器响应请求，分配 IP 地址，并提供引导服务器（通常是 TFTP 服务器）的地址。
- PXE 引导请求：

  - 计算机发送一个 PXE 引导请求到引导服务器，请求引导文件（通常是一个小的可执行程序）。
- 引导文件传输：
  - 引导服务器通过 TFTP（Trivial File Transfer Protocol）将引导文件传输到计算机。
- 加载引导文件：
  - 计算机加载并执行引导文件，该文件通常包含启动加载程序（如 GRUB 或 Windows Boot Manager），用于引导操作系统的安装或启动。
- 操作系统加载：
  - 启动加载程序从网络或本地存储设备加载操作系统，并启动计算机。
#### 分区:
**主分区**：
- 一个硬盘最多可以有四个主分区。
- 主分区直接创建在硬盘的分区表中
**扩展分区**:
- 一种特殊的主分区，用于克服主分区数量限制的问题
- 扩展分区本身不存储数据，但可以包含多个逻辑分区。
- 一个硬盘上只能有一个扩展分区
- 扩展分区内可以创建多个逻辑分区
**逻辑分区**:
- 数量不受限制
- 逻辑分区可以用于存储数据或安装额外的操作系统
- 逻辑分区不能被标记为活动分区，不能直接引导操作系统
**交换分区**:
- 虚拟内存管理，扩展物理内存
- 主要用于Linux系统
**恢复分区**:
- 包含系统恢复工具和系统映像，用于恢复出厂设置或修复系统
- 通常由OEM厂商预设在计算机上
**EFI系统分区**:
- 必须存在于使用UEFI引导的系统上
- 用于存储UEFI引导加载程序和相关文件

#### 分区表类型:
**主引导记录(MBR)**:

- 将驱动器的前 512 字节加载到内存地址 0x007C00 中，并使用跳转指令将程序控制传输到处理器
- 识别出多个具有适当引导扇区的驱动器，它将从具有最高预分配优先级的驱动器引导；这正是为什么大多数计算机默认从 USB 启动而不是从硬盘启动（如果在启动时插入可启动 USB 驱动器）

- MBR 启动使用传统 BIOS
- 每个硬盘最多支持四个主分区。
- 一个分区表占用64字节，每个分区项占用16字节，共4表项
- 只为引导加载程序留下了 434 到 446 字节的可用空间
- 支持最大2TB的硬盘。
- 当处理器处于实模式而不是保护模式时，执行将传递给引导程序代码，这意味着（除其他外）可以访问您所知道和使用的操作系统的所有这些强大功能,这意味着我们可以直接访问 BIOS中断调用

- 主引导记录: 
    - 一个程序负责在计算机启动时加载操作系统
    - 查找活动分区，并将控制权交付
- 分区表
- 魔数（Magic Number）：用于验证MBR的完整性。它通常是0xAA55



###### 活动分区:
- 引导标志:指示哪个分区是活动的。只有一个分区可以被标记为活动分区。
- 引导代码（Boot Code）：存储在活动分区的引导扇区（通常是分区的第一个扇区）
###### 逻辑块地址( LBA):
- LBA是一种线性寻址方式，将存储设备上的所有扇区编号成连续的块，并为每个块分配一个唯一的编号。每个扇区都有一个唯一的LBA编号，从0开始依次递增。
###### 实模式:
- 在实模式下，内存使用逻辑地址而不是物理地址进行寻址
- 这里的逻辑地址指的是段+偏移  实际上是内存上的实际地址
- 是x86处理器上电或复位后的默认操作模式
- 使用20位地址总线，可以直接访问1MB的内存

- 没有内置的内存保护机制，所有程序可以访问所有内存地址，包括操作系统内核和其他程序的内存。

- 运行在实模式下的程序可以直接访问硬件设备和I/O端口。实模式支持16位寄存器和指令，兼容8086处理器。

- 使用中断向量表（IVT），表格位于内存地址0x0000到0x03FF，每个中断向量占用4字节。
- 进入实模式：处理器上电或复位后默认进入实模式。
  - 初始化必要的硬件和数据结构：设置段描述符表（GDT）和中断描述符表（IDT）。
  - 启用保护模式：通过设置控制寄存器CR0的PE位（保护使能位）启用保护模式。
  - 跳转到保护模式代码段：执行跳转指令，进入保护模式下的代码执行。

###### 保护模式:
- 保护模式是x86处理器从80286开始引入的一种增强操作模式，提供了更强大的内存管理和保护功能。其特点包括：
- 保护模式使用32位地址总线，可以访问高达4GB的内存
- 使用段选择器和段描述符的方式管理内存，通过段描述符表（GDT和LDT）实现段到物理内存的映射。
- 保护模式支持虚拟内存，通过分页机制将虚拟地址映射到物理地址。
- 支持32位寄存器和指令集，增强了处理器的性能和功能。
- 保护模式使用中断描述符表（IDT），提供更灵活和安全的中断处理机制

###### 链式加载:
- 链式加载类似于覆盖的使用。然而，与覆盖不同的是，链式加载会完全替换当前正在执行的程序。覆盖通常仅替换正在运行的程序的一部分。与使用覆盖一样，使用链式加载也会增加应用程序的 I/O负载。
**GPT(全局唯一标识符分区表)**:
- 它是EFI标准的一部分，通常与UEFI配合使用。
- 使用全局唯一标识符（GUID）管理分区
- 支持更大容量的硬盘（最大支持18EB）
- 支持无限多个分区（实际受限于操作系统）
###### EFI 系统分区:

- UEFI 启动使用 EFI（或 UEFI），提供了更现代和灵活的启动选项。
- 是GUID分区表（GPT）的系统中一个专用分区
- 通常使用FAT32文件系统格式
- ESP的分区类型GUID为 C12A7328-F81F-11D2-BA4B-00A0C93EC93B
- 包含系统引导程序，对于Windows操作系统，包含 BOOTMGR 文件和 EFI\Microsoft\Boot 目录；对于Linux系统，可能包含 GRUB 或其他引导加载程序文件。

_创建EFI_:
- 安装操作系统时，安装程序通常会自动创建和配置ESP
- 手动分区时用户可以按照以下步骤创建ESP：

  - 选择合适的大小：确保ESP的大小足够存储所有必要的引导文件和UEFI应用程序。
  - 设置文件系统：格式化ESP为FAT32文件系统。
  - 设置分区标识：在GPT分区表中，将分区类型设置为EFI系统分区的GUID。
###### GPT的结构:
_保护MBR（Protective MBR）_：
位于硬盘的第一个扇区（LBA 0）。
用于保护GPT分区表，使得不支持GPT的旧软件不会误识别磁盘为未分区状态。

_GPT头（GPT Header）_：
紧接在保护MBR之后，通常位于LBA 1。
包含GPT的元数据，包括分区表的起始位置和分区数量。

_分区表数组（Partition Entry Array）_：

紧跟在GPT头之后，包含每个分区的详细信息。
每个分区条目占用128字节，标准GPT支持最多128个分区条目。


_备份GPT头和分区表数组：_
位于磁盘末尾，用于冗余保护。

#### GRUB(GRand Unified Boot):
- GRUB 将通过跳转到内存中的某个位置来将控制权转移给操作系统。
- 跳转之前，GRUB 将查找一个幻数以确保它实际上跳转到操作系统而不是一些随机代码
- 这个幻数是GRUB 遵守的多重引导规范的一部分
- 引导加载程序了解底层文件系统，以便使用其实际文件路径来配置和访问内核映像
- GRUB 在大于或等于（1 兆字节 (MB)）的内存地址加载内核0x00100000，因为低于 1 MB 的地址由 GRUB 本身、BIOS 和内存映射 I/O 使用。
- 内核映像文件:
  - 内核映射文件通常是一个文本文件，其中每一行描述了一个内核映像在磁盘上的物理位置，通常使用硬盘扇区号表示。
  - 例如：
    - /boot/vmlinuz-5.13.0-30-generic    0x00000001其中，/boot/vmlinuz-5.13.0-30-generic 是内核映像的路径，0x00000001 是内核映像在磁盘上的物理起始扇区号
**GRUB 0.x**:
GRUB 0.x 遵循两阶段方法:
- Stage 1 是 GRUB 引导加载过程中的第一个阶段。它位于硬盘的 MBR（主引导记录）中，通常称为 MBR Gap。stage1 的主要作用是加载 stage1.5 或 stage2，并将控制权传递给它们。

- tage1.5：位于文件系统的 Boot Record 中。stage1.5 可以读取文件系统，以便加载 stage2，并且通常用于加载 stage2。stage1.5 的位置通常是文件系统的第一个扇区。


**GRUB 2**:
- stage2：Stage 2 是 GRUB 的第二个阶段，也是最重要的阶段之一。它通常位于文件系统的某个位置（例如，/boot/grub/stage2），stage1 或 stage1.5 负责加载 stage2。在 stage2 中，GRUB 能够读取文件系统、加载内核、配置文件和模块，并提供引导菜单等功能。
- grub.cfg：GRUB 的配置文件，通常位于 /boot/grub/grub.cfg。它包含了 GRUB 引导菜单的配置信息，包括引导选项、内核参数、菜单项等。
- GRUB Menu：GRUB 引导菜单是用户在引导时看到的菜单，提供了多个操作系统或内核选项供用户选择。用户可以在菜单中选择一个选项以启动相应的操作系统或内核。

###### 多重引导规范主要部分:
- 多重引导头:
  - 该头部告诉引导加载程序如何加载内核
  - 头部必须位于内核映像的前8192字节中，且必须对齐到4字节边界
- 引导信息结构:
  - 引导加载程序在启动内核时会传递一个结构体给内核，包含各种引导信息，如内存映射、内核命令行、模块信息等
- 内核启动：

  - 引导加载程序将内核加载到内存中，并将控制权转移给内核。
  - 内核从一个指定的入口点开始执行。

**内核**:
- 内核作为文件存储在适当的文件系统上，但 BIOS 不知道文件系统的概念。因此，在基于 BIOS 的系统中，引导加载程序的职责是访问这些文件的内容，以便将其加载到 RAM 中并执行。
**帧缓冲区**:
- 帧缓冲区是一种能够在屏幕上显示内存缓冲区的硬件设备
- 帧缓冲区有 80 列和 25 行
- 帧缓冲区将文本写入控制台是通过内存映射 I/O
- 帧缓冲区的内存映射 I/O 的起始地址是0x000B8000 
Bit:     | 15 14 13 12 11 10 9 8 | 7 6 5 4 | 3 2 1 0 |
Content: | ASCII                 | FG      | BG      |
**移动光标**：
- 移动帧缓冲区的光标是通过两个不同的 I/O 端口完成的
- 光标的位置由一个 16 位整数确定：0 表示第 0 行、第 0 列； 1 表示第 0 行、第 1 列； 80 表示第一行、零列
- out汇编代码指令参数为 8 位，分两部分输出，先发送前 8 位，然后发送接下来的 8 位
- 端口0x3D4是描述数据的端口，端口0x3D5 用于数据本身。


      out 0x3D4, 14      ; 14 tells the framebuffer to expect the highest 8  bits of the position
      out 0x3D5, 0x00    ; sending the highest 8 bits of 0x0050
      out 0x3D4, 15      ; 15 tells the framebuffer to expect the lowest 8 bits of the position
      out 0x3D5, 0x50    ; sending the lowest 8 bits of 0x0050

**链接器脚本**:
- 链接器脚本（Linker Script）是一种用于指导链接器（linker）如何将目标文件（object files）组合成最终的可执行文件或共享库的文本文件。它定义了各个部分在内存中的布局和排列方式，包括代码段、数据段、堆栈、符号表等。
----
**BIOS中断服务**:
- 中断号:
 10

- 中断服务号:
  - AH = 07h SCROLL DOWN WINDOW
      - AL = number of lines by which to scroll down (00h=clear entire window)
      - BH = BIOS 颜色属性  (0x07H) 黑色背景白色字体   
      - CH,CL = row,column   从左上角开始
      - DH,DL = row,column   到右下角的矩形区域

      - Return: Nothing
  - AH = 02H SET CURSOR POSITION
      - BH =  以便通过在向用户显示离屏内容之前渲染离屏内容来促进更平滑的视觉过渡。这称为多重缓冲或双缓冲 
          - 0-3 in modes 2&3
          - 0-7 in modes 0&1
          - 0 in graphics modes
          - DH = row (00h is top)
      - DL = column (00h is left)

  - AH = 0Eh TELETYPE OUTPUT "Oh boy do I sure love assembly!", 0 以0 结尾的字符串
      - AL = character to write
      - BH = page number
      - BL = foreground color (graphics modes only)

####  分段
- 要启用分段，您需要建立一个描述每个段的表——段描述符表。在x86中，有两种类型的描述符表：全局描述符表（GDT）和局部描述符表（LDT）。 LDT由用户空间进程建立和管理，所有进程都有自己的LDT。如果需要更复杂的分割模型，可以使用 LDT - 我们不会使用它。 GDT 是所有人共享的——它是全球性的。

index | offset | name | Address range |Type	| DPL

- DPL 指定使用该段所需的权限级别。 x86 允许四个特权级别 (PL)，0 到 3，其中 PL0 的特权最高。在大多数操作系统（例如 Linux 和 Windows）中，仅使用 PL0 和 PL3。然而，某些操作系统，例如 MINIX，会利用所有级别。内核应该能够执行任何操作，因此它使用 DPL 设置为 0 的段（也称为内核模式）。当前特权级（CPL）由 中的段选择器确定cs。

**加载GDT**:
GDT 加载到处理器中是通过lgdt汇编代码指令完成的，该指令采用指定 GDT 的起始位置和大小的结构体的地址

- lgdt [eax]
  - rpl 请求的权限级别
  - ti（指示使用哪个表）2 : 表指示器。 0表示指定GDT段，1表示LDT段。
  - offset (index)  3- 15: 0x08，表示要访问 GDT 中的第一个段描述符，乘以8即得到描述符在 GDT 中的地址为 0x08 * 8 = 0x40。


#### 约定:
- 调用者有责任在被调用者返回后清理堆栈，这相当于通过移动堆栈指针从堆栈顶部删除参数。

- 调用保存状态: 相关寄存器 -> 过程参数 -> 断点

- 让我们在引导加载程序的 512 字节之后直接开始堆栈的存储。由于引导加载程序从 0x7C00 延伸 512 字节到 0x7E00，因此堆栈段 SS 将为 0x7E0。
- 在 x86 架构上，堆栈指针会减小，因此我们必须将初始堆栈指针设置为堆栈段后面的字节数，等于所需的堆栈大小。由于堆栈段可以寻址 64k 内存，因此我们通过将 SP 设置为 0x2000 来创建一个 8k 堆栈。
## 用户模式：
#### 加载外部程序：
- 使用 GRUB 中称为模块的功能来加载程序，而不是创建所有这些驱动程序和文件系统。
- GRUB 可以从 ISO 映像加载任意文件到内存中，这些文件通常称为模块。
- 使 GRUB 加载模块，请编辑该文件iso/boot/grub/menu.lst并在文件末尾添加以下行：
  -  module /modules/program
   
  
----

**细节**:
- 在内核的ELF文件中的section中保留一块bss未初始化的内存。最好使用bss节而不是data节来减少操作系统可执行文件的大小。由于 GRUB 理解 ELF，因此 GRUB 将bss在加载操作系统时分配该部分中保留的任何内存。

- 汇编代码调用 C 代码有许多不同的约定。
  - cdecl调用约定，这是 GCC 使用的调用约定。
    - 函数的参数应通过堆栈传递（在 x86 上），按从右到左的顺序压入堆栈
    - 返回值存放在eax寄存器中
----


## 文档:
**GRUB**:
https://en.wikipedia.org/wiki/GNU_GRUB
**BIOS中断服务**:
https://www.ctyme.com/intr/rb-0087.htm



